# -*- coding: utf-8 -*-

import time
import pandas as pd
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import argparse, traceback

# === CONFIG ===
TRADINGVIEW_BASE_URL = "https://www.tradingview.com/chart/0RKjg68o/"
EXCEL_FILE = "tradingview_backtest_results.xlsx"
BEST_SHEET = "Best_Per_Symbol"

# Param√®tres par d√©faut si pas trouv√©s dans l'Excel
DEFAULT_ATR = 1.2
DEFAULT_RR = 2.7
DEFAULT_VOL = 0.8

def load_best_parameters():
    """Charge les meilleurs param√®tres depuis l'Excel d'analyse."""
    if not os.path.exists(EXCEL_FILE):
        print(f"‚ùå Fichier {EXCEL_FILE} non trouv√©. Utilisation des param√®tres par d√©faut.")
        return {}
    
    try:
        df_best = pd.read_excel(EXCEL_FILE, sheet_name=BEST_SHEET, engine='openpyxl')
        
        if df_best.empty:
            print(f"‚ùå Feuille {BEST_SHEET} vide. Utilisation des param√®tres par d√©faut.")
            return {}
        
        # Convertir en dictionnaire {Symbol: {ATR, RR, Vol}}
        best_params = {}
        for _, row in df_best.iterrows():
            symbol = row.get('Symbol')
            if symbol:
                best_params[symbol] = {
                    'ATR': row.get('Best ATR Multiplier', DEFAULT_ATR),
                    'RR': row.get('Best RR', DEFAULT_RR), 
                    'Vol': row.get('Best Vol Multiplier', DEFAULT_VOL)
                }
        
        print(f"‚úÖ Charg√© {len(best_params)} symboles avec param√®tres optimaux:")
        for symbol, params in best_params.items():
            print(f"  {symbol}: ATR={params['ATR']}, RR={params['RR']}, Vol={params['Vol']}")
        
        return best_params
        
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement de {EXCEL_FILE}: {e}")
        return {}

def setup_driver():
    """Configure et initialise le driver Chrome avec remote debugging."""
    options = Options()
    options.add_argument("--window-size=1920,1080")
    options.debugger_address = "127.0.0.1:9222"
    
    try:
        driver = webdriver.Chrome(options=options)
        print("‚úÖ Driver Chrome connect√© avec succ√®s")
        return driver
    except Exception as e:
        print(f"‚ùå Impossible de connecter le driver Chrome: {e}")
        print("üí° Assurez-vous que Chrome est lanc√© avec --remote-debugging-port=9222")
        return None

def set_strategy_parameters(driver, atr, rr, vol_mult):
    """Configure les param√®tres de la strat√©gie."""
    print(f"üîß Configuration ATR={atr}, RR={rr}, Vol={vol_mult}")
    
    try:
        # Ouvrir les param√®tres avec Cmd+P
        actions = ActionChains(driver)
        actions.key_down(Keys.COMMAND).send_keys('p').key_up(Keys.COMMAND).perform()
        time.sleep(2)
        
        # ATR Multiplier
        atr_input = driver.find_element(
            By.XPATH,
            "//div[contains(text(),'ATR Stop Multiplier') or contains(text(),'Multiplicateur ATR')]/parent::div/following-sibling::div//input"
        )
        atr_input.click()
        actions.key_down(Keys.COMMAND).send_keys('a').key_up(Keys.COMMAND).perform()
        atr_input.send_keys(str(atr))
        
        # Risk/Reward Ratio
        rr_input = driver.find_element(
            By.XPATH,
            "//div[contains(text(),'Base Risk/Reward Ratio') or contains(text(),'Ratio Risque/Rendement de base')]/parent::div/following-sibling::div//input"
        )
        rr_input.click()
        actions.key_down(Keys.COMMAND).send_keys('a').key_up(Keys.COMMAND).perform()
        rr_input.send_keys(str(rr))
        
        # Volatility Multiplier
        vol_input = driver.find_element(
            By.XPATH,
            "//div[contains(text(),'Dynamic: Min Volatility Multiplier') or contains(text(),'Multiplicateur minimal de volatilit√© dynamique')]/parent::div/following-sibling::div//input"
        )
        vol_input.click()
        actions.key_down(Keys.COMMAND).send_keys('a').key_up(Keys.COMMAND).perform()
        vol_input.send_keys(str(vol_mult))
        
        # Appliquer les changements
        actions.send_keys(Keys.TAB).perform()
        time.sleep(1)
        
        # Attendre que la snackbar disparaisse
        try:
            WebDriverWait(driver, 3).until_not(
                EC.presence_of_element_located((By.CLASS_NAME, "snackbarLayer-_MKqWk5g"))
            )
        except:
            pass
        
        print("‚úÖ Param√®tres configur√©s avec succ√®s")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la configuration des param√®tres: {e}")
        return False

def delete_existing_alerts(driver):
    """Supprime toutes les alertes existantes cr√©√©es par ce script."""
    try:
        print("üßπ Suppression des alertes existantes...")
        
        # Aller √† la page des alertes
        driver.get("https://www.tradingview.com/u/alerts/")
        time.sleep(3)
        
        # Attendre que la page se charge
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//div[contains(@class, 'alerts')]"))
        )
        
        deleted_count = 0
        max_attempts = 50  # Limite pour √©viter les boucles infinies
        
        for attempt in range(max_attempts):
            try:
                # Chercher les alertes cr√©√©es par notre script (contenant "Optimal Strategy Alert")
                alert_rows = driver.find_elements(
                    By.XPATH, 
                    "//tr[.//td[contains(text(), 'Optimal Strategy Alert')]]"
                )
                
                if not alert_rows:
                    # Essayer un autre s√©lecteur si le premier ne fonctionne pas
                    alert_rows = driver.find_elements(
                        By.XPATH, 
                        "//div[contains(text(), 'Optimal Strategy Alert')]/ancestor::tr"
                    )
                
                if not alert_rows:
                    # S√©lecteur alternatif pour les alertes en g√©n√©ral
                    alert_rows = driver.find_elements(
                        By.XPATH, 
                        "//div[contains(@data-name, 'alert-item') and .//text()[contains(., 'Optimal Strategy Alert')]]"
                    )
                
                if not alert_rows:
                    print(f"‚úÖ Aucune alerte de script trouv√©e (tentative {attempt + 1})")
                    break
                
                # Supprimer la premi√®re alerte trouv√©e
                alert_row = alert_rows[0]
                
                # Chercher le bouton de suppression (ic√¥ne poubelle ou menu)
                delete_selectors = [
                    ".//div[@data-name='alert-delete-button']",
                ]
                
                delete_button = None
                for selector in delete_selectors:
                    try:
                        delete_button = alert_row.find_element(By.XPATH, '..').find_element(By.XPATH, selector)
                        break
                    except:
                        continue
                
                if delete_button:
                    # Faire d√©filer vers l'√©l√©ment si n√©cessaire
                    driver.execute_script("arguments[0].scrollIntoView(true);", delete_button)
                    time.sleep(0.5)
                    
                    # Cliquer sur le bouton de suppression
                    driver.execute_script("arguments[0].click();", delete_button)
                    time.sleep(1)
                    
                    # Confirmer la suppression si une bo√Æte de dialogue appara√Æt
                    try:
                        confirm_selectors = [
                            "//button[contains(text(), 'Delete') or contains(text(), 'Supprimer')]",
                            "//button[contains(text(), 'Confirm') or contains(text(), 'Confirmer')]",
                            "//button[contains(text(), 'Yes') or contains(text(), 'Oui')]",
                            "//button[@name='yes']",
                            "//button[@data-name='confirm']"
                        ]
                        
                        for confirm_selector in confirm_selectors:
                            try:
                                confirm_button = WebDriverWait(driver, 2).until(
                                    EC.element_to_be_clickable((By.XPATH, confirm_selector))
                                )
                                confirm_button.click()
                                break
                            except:
                                continue
                    except:
                        pass  # Pas de confirmation n√©cessaire
                    
                    deleted_count += 1
                    print(f"üóëÔ∏è Alerte {deleted_count} supprim√©e")
                    time.sleep(1)  # Attendre que la suppression soit effective
                    
                else:
                    print("‚ö†Ô∏è Bouton de suppression non trouv√© pour cette alerte")
                    # Essayer de cliquer droit pour ouvrir le menu contextuel
                    try:
                        actions = ActionChains(driver)
                        actions.context_click(alert_row).perform()
                        time.sleep(1)
                        
                        # Chercher l'option "Delete" dans le menu contextuel
                        context_delete = driver.find_element(
                            By.XPATH, 
                            "//div[contains(@class, 'context-menu')]//div[contains(text(), 'Delete') or contains(text(), 'Supprimer')]"
                        )
                        context_delete.click()
                        
                        deleted_count += 1
                        print(f"üóëÔ∏è Alerte {deleted_count} supprim√©e (menu contextuel)")
                        time.sleep(1)
                        
                    except:
                        print("‚ö†Ô∏è Impossible de supprimer cette alerte, passage √† la suivante")
                        break
                        
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur lors de la suppression d'alerte: {e}")
                print(traceback.print_exc())
                break
        
        print(f"‚úÖ Suppression termin√©e: {deleted_count} alertes supprim√©es")
        return deleted_count
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la suppression des alertes: {e}")
        return 0

def create_alert(driver, symbol, condition="Signal"):
    """Cr√©e une alerte pour le symbole en utilisant la page d'alertes directe."""
    try:
        print(f"üö® Cr√©ation d'alerte pour {symbol}...")
        
        
        # Chercher le bouton "Create Alert" ou √©quivalent
        create_alert_selectors = [
            "//button[contains(text(), 'Create Alert') or contains(text(), 'Create alert') or contains(text(), 'New Alert')]",
            "//div[contains(text(), 'Create Alert') or contains(text(), 'Create alert') or contains(text(), 'New Alert')]",
            "//a[contains(text(), 'Create Alert') or contains(text(), 'Create alert') or contains(text(), 'New Alert')]",
            "//button[contains(@class, 'create') and contains(@class, 'alert')]",
            "//*[contains(@aria-label, 'Create alert') or contains(@aria-label, 'create alert')]",
            "//button[@aria-label='Create Alert']"
        ]
        
        create_button = None
        for selector in create_alert_selectors:
            buttons = driver.find_elements(By.XPATH, selector)
            print(f"   üîç S√©lecteur '{selector[:50]}...': {len(buttons)} boutons trouv√©s")
            if buttons:
                for i, button in enumerate(buttons):
                    try:
                        if button.is_displayed() and button.is_enabled():
                            create_button = button
                            button_text = button.text or button.get_attribute('aria-label') or f"Button {i}"
                            print(f"   ‚úÖ Bouton de cr√©ation trouv√©: {button_text}")
                            break
                    except:
                        continue
                if create_button:
                    break
        
        if not create_button:
            print(f"   ‚ùå Aucun bouton de cr√©ation d'alerte trouv√©")
            # Essayer un raccourci clavier Alt+A comme alternative
            print("   ÔøΩ Tentative avec raccourci Alt+A...")
            actions = ActionChains(driver)
            actions.key_down(Keys.ALT).send_keys('a').key_up(Keys.ALT).perform()
            time.sleep(3)
        else:
            # Cliquer sur le bouton de cr√©ation
            print(f"   üñ±Ô∏è Clic sur le bouton de cr√©ation...")
            driver.execute_script("arguments[0].scrollIntoView(true);", create_button)
            time.sleep(1)
            create_button.click()
            time.sleep(3)
        
         
        # √âTAPE 1: S√©lectionner la strat√©gie dans la condition
        print("üîß Configuration de la condition - S√©lection de la strat√©gie...")
        try:
            # Chercher le dropdown "Condition" qui contient "Price" par d√©faut
            condition_selectors = [
                "//span[contains(text(), 'Price')]/parent::div/parent::div",  # 
            ]
            
            condition_dropdown = None
            for selector in condition_selectors:
                try:
                    condition_dropdown = driver.find_element(By.XPATH, selector)
                    print(f"‚úÖ Dropdown condition trouv√© avec: {selector}")
                    break
                except:
                    continue
            
            if condition_dropdown:
                # Cliquer sur le dropdown pour l'ouvrir
                driver.execute_script("arguments[0].scrollIntoView(true);", condition_dropdown)
                time.sleep(0.5)
                condition_dropdown.click()
                time.sleep(2)
                
                # Chercher notre strat√©gie dans la liste
                strategy_selectors = [
                    "//span[contains(text(), 'Swing Bollinger Mean Reversion') and contains(@class, 'apply-overflow-tooltip')]",
                ]
                
                strategy_option = None
                for selector in strategy_selectors:
                    try:
                        strategy_option = WebDriverWait(driver, 3).until(
                            EC.element_to_be_clickable((By.XPATH, selector))
                        )
                        print(f"‚úÖ Strat√©gie trouv√©e avec: {selector}")
                        break
                    except:
                        continue
                
                if strategy_option:
                    strategy_option.click()
                    time.sleep(1)
                    print("‚úÖ Strat√©gie 'Swing Bollinger Mean Reversion' s√©lectionn√©e")
                else:
                    print("‚ö†Ô∏è Strat√©gie 'Swing Bollinger Mean Reversion' non trouv√©e dans la liste")
                    # Lister les options disponibles pour debug
                    available_options = driver.find_elements(By.XPATH, "//div[contains(@class, 'option')] | //option | //li[contains(@class, 'item')]")
                    print(f"   Options disponibles ({len(available_options)}):")
                    for i, option in enumerate(available_options[:10]):
                        try:
                            option_text = option.text.strip()
                            if option_text:
                                print(f"     {i}: {option_text}")
                        except:
                            pass
            else:
                print("‚ö†Ô∏è Dropdown condition non trouv√©")
                
        except Exception as condition_e:
            print(f"‚ö†Ô∏è Erreur lors de la s√©lection de la strat√©gie: {condition_e}")
        
        # √âTAPE 2: Cliquer sur l'onglet Message
        print("üîç Clic sur l'onglet Message...")
        try:
            message_tab = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.ID, "alert-dialog-tabs__message"))
            )
            message_tab.click()
            time.sleep(2)  # Attendre plus longtemps que l'onglet se charge
            print("‚úÖ Onglet Message activ√©")
        except Exception as tab_e:
            print(f"‚ö†Ô∏è Erreur lors du clic sur l'onglet Message: {tab_e}")
            # Essayer un s√©lecteur alternatif
            try:
                message_tab = driver.find_element(By.XPATH, "//div[contains(text(), 'Message') and contains(@class, 'tab')]")
                message_tab.click()
                time.sleep(2)
                print("‚úÖ Onglet Message activ√© (s√©lecteur alternatif)")
            except:
                print("‚ö†Ô∏è Impossible de trouver l'onglet Message")
        
        # Configuration du nom de l'alerte
        alert_name = f"{symbol} - Optimal Strategy Alert"
        
        # Chercher le champ nom de l'alerte avec plusieurs s√©lecteurs
        print("üîç Recherche du champ nom d'alerte...")
        name_selectors = [
            "//input[@placeholder='Alert name']",
            "//input[@placeholder='Nom de l'alerte']",
            "//input[contains(@class, 'name')]",
            "//div[contains(@class, 'dialog')]//input[1]"
        ]
        
        name_input = None
        for selector in name_selectors:
            try:
                name_input = driver.find_element(By.XPATH, selector)
                print(f"‚úÖ Champ nom trouv√© avec: {selector}")
                break
            except:
                continue
        
        if name_input:
            try:
                # Faire d√©filer vers l'√©l√©ment et le rendre visible
                driver.execute_script("arguments[0].scrollIntoView(true);", name_input)
                time.sleep(0.5)
                
                name_input.clear()
                name_input.send_keys(alert_name)
                print(f"‚úÖ Nom configur√©: {alert_name}")
            except Exception as name_e:
                print(f"‚ö†Ô∏è Erreur configuration nom: {name_e}")
        else:
            print("‚ö†Ô∏è Champ nom d'alerte non trouv√©, utilisation du nom par d√©faut")
        
        # Configuration du message d'alerte (format JSON pour webhooks)
        alert_message = f"""{{
  "strategy": "Swing Bollinger Mean Reversion",
  "ticker": "{{{{ticker}}}}",
  "interval": "{{{{interval}}}}",
  "side": "{{{{strategy.order.action}}}}",
  "order_id": "{{{{strategy.order.id}}}}",
  "position_size": "{{{{strategy.position_size}}}}",
  "market_position_size": "{{{{strategy.market_position_size}}}}",
  "entry_price": "{{{{strategy.order.price}}}}",
  "date": "{{{{time}}}}",
  "comment": "{{{{strategy.order.comment}}}}",
  "optimized_params": {{
    "atr_multiplier": {getattr(driver, 'current_atr', 1.2)},
    "risk_reward": {getattr(driver, 'current_rr', 2.7)},
    "vol_multiplier": {getattr(driver, 'current_vol', 0.8)}
  }}
}}"""
        
        # Chercher le champ message avec plusieurs s√©lecteurs
        print("üîç Recherche du champ message...")
        message_selectors = [
            "//textarea[@id='alert-message']",  # ID sp√©cifique
            "//textarea[@placeholder='Message']",
            "//textarea[@placeholder='Message (Optional)']",
            "//textarea[contains(@class, 'message')]",
            "//div[contains(@class, 'message')]//textarea",
            "//textarea[contains(@data-name, 'message')]",
            "//div[contains(@class, 'dialog')]//textarea"
        ]
        
        message_input = None
        # Essayer d'abord avec l'ID sp√©cifique
        try:
            message_input = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.ID, "alert-message"))
            )
            print("‚úÖ Champ message trouv√© avec ID: alert-message")
        except:
            # Si l'ID ne fonctionne pas, essayer les autres s√©lecteurs
            for selector in message_selectors:
                try:
                    message_input = WebDriverWait(driver, 2).until(
                        EC.presence_of_element_located((By.XPATH, selector))
                    )
                    print(f"‚úÖ Champ message trouv√© avec: {selector}")
                    break
                except:
                    continue
        
        if message_input:
            try:
                # Faire d√©filer vers l'√©l√©ment et le rendre visible
                driver.execute_script("arguments[0].scrollIntoView(true);", message_input)
                time.sleep(0.5)
                
                # Cliquer d'abord pour s'assurer que le champ est actif
                message_input.click()
                time.sleep(0.2)
                
                # Effacer compl√®tement le contenu existant
                print("üßπ Effacement du contenu existant du champ message...")
                actions = ActionChains(driver)
                actions.key_down(Keys.COMMAND).send_keys('a').key_up(Keys.COMMAND).perform()
                time.sleep(0.1)
                actions.send_keys(Keys.DELETE).perform()
                time.sleep(0.2)
                
                # Double v√©rification avec clear()
                message_input.clear()
                time.sleep(0.2)
                
                # Ins√©rer notre message
                message_input.send_keys(alert_message)
                print("‚úÖ Message configur√© avec succ√®s")
                
            except Exception as msg_e:
                print(f"‚ö†Ô∏è Erreur configuration message: {msg_e}")
                # Essayer une approche alternative avec ActionChains
                try:
                    print("üîÑ Tentative alternative avec ActionChains...")
                    actions = ActionChains(driver)
                    actions.move_to_element(message_input).click().perform()
                    time.sleep(0.2)
                    
                    # Effacement complet avec s√©lection totale + suppression
                    actions.key_down(Keys.COMMAND).send_keys('a').key_up(Keys.COMMAND).perform()
                    time.sleep(0.1)
                    actions.send_keys(Keys.DELETE).perform()
                    time.sleep(0.2)
                    
                    # Ins√©rer le message
                    actions.send_keys(alert_message).perform()
                    print("‚úÖ Message configur√© avec ActionChains")
                except Exception as alt_e:
                    print(f"‚ö†Ô∏è Erreur alternative message: {alt_e}")
        else:
            print("‚ö†Ô∏è Champ message non trouv√©")
        
        # Cr√©er l'alerte - Essayer plusieurs s√©lecteurs pour le bouton
        print("üîç Recherche du bouton de cr√©ation...")
        create_selectors = [
            "//button[contains(text(), 'Create')]",
            "//button[contains(text(), 'Cr√©er')]", 
            "//button[contains(text(), 'CREATE')]",
            "//button[@data-name='submit']",
            "//button[@data-name='create']",
            "//button[contains(@class, 'create')]",
            "//button[contains(@class, 'submit')]",
            "//div[contains(@class, 'dialog')]//button[last()]",
            "//button[contains(@class, 'primary')]"
        ]
        
        create_button = None
        for selector in create_selectors:
            try:
                create_button = WebDriverWait(driver, 2).until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
                print(f"‚úÖ Bouton de cr√©ation trouv√© avec: {selector}")
                break
            except:
                continue
        
        if create_button:
            try:
                # Faire d√©filer vers le bouton
                driver.execute_script("arguments[0].scrollIntoView(true);", create_button)
                time.sleep(0.5)
                
                # Essayer de cliquer
                create_button.click()
                print("‚úÖ Bouton de cr√©ation cliqu√©")
                
                # Attendre que l'alerte soit cr√©√©e
                time.sleep(3)
                
                # V√©rifier si l'alerte a √©t√© cr√©√©e (la bo√Æte de dialogue se ferme)
                try:
                    WebDriverWait(driver, 5).until_not(
                        EC.presence_of_element_located((By.XPATH, "//div[contains(@class, 'dialog')]"))
                    )
                    print(f"‚úÖ Alerte cr√©√©e avec succ√®s pour {symbol}")
                    return True
                except:
                    print("‚ö†Ô∏è La bo√Æte de dialogue est encore ouverte, possible erreur")
                    return False
                    
            except Exception as click_e:
                print(f"‚ùå Erreur lors du clic sur le bouton: {click_e}")
                return False
        else:
            print("‚ùå Bouton de cr√©ation non trouv√©")
            
            # Essayer d'utiliser la touche Entr√©e comme alternative
            try:
                print("üîÑ Tentative avec la touche Entr√©e...")
                actions = ActionChains(driver)
                actions.send_keys(Keys.ENTER).perform()
                time.sleep(2)
                return True
            except:
                return False
            
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale lors de la cr√©ation d'alerte: {e}")
        return False

def create_alerts_for_symbols(best_params, symbols_to_process=None, dry_run=False):
    """Cr√©e les alertes pour tous les symboles avec leurs param√®tres optimaux."""
    
    if not best_params:
        print("‚ùå Aucun param√®tre optimal charg√©. Arr√™t du script.")
        return
    
    # Filtrer les symboles si sp√©cifi√©
    if symbols_to_process:
        filtered_params = {k: v for k, v in best_params.items() if k in symbols_to_process}
        if not filtered_params:
            print(f"‚ùå Aucun des symboles sp√©cifi√©s trouv√©: {symbols_to_process}")
            return
        best_params = filtered_params
    
    if dry_run:
        print("üß™ MODE DRY-RUN: Simulation sans cr√©ation d'alertes")
        for symbol, params in best_params.items():
            print(f"üîç {symbol}: ATR={params['ATR']}, RR={params['RR']}, Vol={params['Vol']}")
        return
    
    driver = setup_driver()
    if not driver:
        return
    
    try:
        # Supprimer toutes les alertes existantes cr√©√©es par ce script
        deleted_count = delete_existing_alerts(driver)
        if deleted_count > 0:
            print(f"üßπ {deleted_count} alertes existantes supprim√©es")
            time.sleep(2)  # Pause apr√®s suppression
        
        successful_alerts = 0
        failed_alerts = 0
        
        for symbol, params in best_params.items():
            print(f"\n{'='*50}")
            print(f"üéØ Traitement de {symbol}")
            print(f"{'='*50}")
            
            # Aller sur le graphique du symbole
            symbol_url = f"{TRADINGVIEW_BASE_URL}?symbol=PEPPERSTONE:{symbol}"
            driver.get(symbol_url)
            time.sleep(5)  # Attendre le chargement
            
            # Stocker les param√®tres actuels dans le driver pour le message d'alerte
            driver.current_atr = params['ATR']
            driver.current_rr = params['RR'] 
            driver.current_vol = params['Vol']
            
            # Configurer les param√®tres optimaux
            if set_strategy_parameters(driver, params['ATR'], params['RR'], params['Vol']):
                
                # Attendre que la strat√©gie se charge avec les nouveaux param√®tres
                time.sleep(3)
                
                # Cr√©er l'alerte
                if create_alert(driver, symbol):
                    successful_alerts += 1
                    print(f"‚úÖ {symbol}: Alerte cr√©√©e avec succ√®s")
                else:
                    failed_alerts += 1
                    print(f"‚ùå {symbol}: √âchec cr√©ation alerte")
            else:
                failed_alerts += 1
                print(f"‚ùå {symbol}: √âchec configuration param√®tres")
            
            # Pause entre les symboles pour √©viter la surcharge
            time.sleep(2)
        
        print(f"\n{'='*50}")
        print(f"üìä R√âSUM√â")
        print(f"{'='*50}")
        print(f"‚úÖ Alertes cr√©√©es avec succ√®s: {successful_alerts}")
        print(f"‚ùå √âchecs: {failed_alerts}")
        print(f"üìà Total trait√©: {successful_alerts + failed_alerts}")
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur g√©n√©rale: {e}")
    finally:
        print("\nüîÑ Fermeture du driver...")
        driver.quit()

def main():
    parser = argparse.ArgumentParser(description="Cr√©er des alertes TradingView avec param√®tres optimaux")
    parser.add_argument('--symbols', nargs='+', help='Symboles sp√©cifiques √† traiter (ex: --symbols EURUSD GBPUSD)')
    parser.add_argument('--dry-run', action='store_true', help='Mode simulation sans cr√©ation d\'alertes')
    parser.add_argument('--list', action='store_true', help='Lister les symboles disponibles')
    
    args = parser.parse_args()
    
    # Charger les meilleurs param√®tres
    best_params = load_best_parameters()
    
    if args.list:
        print("\nüìã Symboles disponibles avec param√®tres optimaux:")
        for symbol in sorted(best_params.keys()):
            params = best_params[symbol]
            print(f"  {symbol}: ATR={params['ATR']}, RR={params['RR']}, Vol={params['Vol']}")
        return
    
    if not best_params:
        print("‚ùå Aucun param√®tre optimal disponible. V√©rifiez votre fichier Excel.")
        return
    
    print("üöÄ D√©marrage de la cr√©ation d'alertes TradingView")
    print("üí° Assurez-vous que:")
    print("   - Chrome est ouvert avec --remote-debugging-port=9222")
    print("   - Vous √™tes connect√© √† TradingView")
    print("   - La strat√©gie est charg√©e sur le graphique")
    
    input("\n‚è∏Ô∏è Appuyez sur Entr√©e pour continuer...")
    
    # Cr√©er les alertes
    create_alerts_for_symbols(
        best_params, 
        symbols_to_process=args.symbols,
        dry_run=args.dry_run
    )

if __name__ == "__main__":
    main()
